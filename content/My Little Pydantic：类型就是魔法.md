---
title: 
aliases: 
tags: 
draft: true
---

Pydantic ä½œä¸º Typed Python ä¸­çš„æ˜æ˜Ÿé¡¹ç›®ï¼Œä½¿ç”¨äº†ä¸å°‘ç±»å‹ç›¸å…³çš„é»‘é­”æ³•ğŸ˜…ã€‚

# å°†é­”æ³•æ®ä¸ºå·±æœ‰

ä½ å¯èƒ½ä¼šè¯´ï¼šæˆ‘å·²ç»çŸ¥é“äº†æ‰€è°“çš„ç±»å‹é­”æ³•ä¸è¿‡æ˜¯ä½¿ç”¨ `__class_getitem__` è€Œå·²ï¼Œæˆ‘å·²ç»è¿«ä¸åŠå¾…è¦æ‰‹æ“è½®å­äº†ï¼

ä½†æˆ‘ä»¬å†…å¿ƒæ·±å¤„å…¶å®éƒ½è®¤åŒä¸è¦é‡å¤é€ è½®å­åŸåˆ™ï¼Œæ‰€ä»¥æœ€ç®€å•çš„æ–¹æ³•è¿˜æ˜¯ç­‰å¾… Pydantic åˆ›å»ºå®Œ concrete model åï¼Œå°† model ä¸­çš„ `annotation` å­—æ®µæå–å‡ºæ¥ï¼š

```python
class TypeWrapper[T](RootModel[T]):
    root: T

    @classmethod
    def type(cls) -> type[T]:
        assert (anno := cls.model_fields["root"].annotation)
        return anno
```

# æœ‰æ²¡æœ‰æ›´é€šç”¨çš„æ–¹æ³•ï¼Ÿ

æœ‰çš„å…„å¼Ÿï¼Œæœ‰çš„ã€‚è®©æˆ‘ä»¬æ¥è®¾è®¡ä¸€ä¸ªæ”¯æŒä»»æ„å±‚ç±»ç»§æ‰¿çš„ TypeVar è§£ææ–¹æ³•ã€‚

é¦–å…ˆå®¡è§†ä¸€ä¸‹ä¸Šè¿°çš„ `TypeWrapper` æ–¹æ³•æœ‰ä½•é—®é¢˜ã€‚å‡è®¾ä½ åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«å¤šä¸ª Type Parameters çš„åŸºç±» `Base`ï¼Œå½“è¡ç”Ÿç±» `Derived` ç»§æ‰¿å®ƒæ—¶ï¼Œå¯èƒ½åªä¼šæŒ‡å®šå…¶ä¸­çš„æŸäº›å‚æ•°ï¼Œè€Œå°†å…¶ä»–å‚æ•°ç•™åˆ°æœ€ç»ˆç±» `Final` æ¥æŒ‡å®šã€‚

å½“æˆ‘ä»¬å‡ºäºæŸäº›åŸå› æƒ³è¦åœ¨åŸºç±»é€»è¾‘ä¸­å°±è·å–åˆ°æœ€ç»ˆç±»é€»è¾‘çš„ç±»å‹ä¿¡æ¯æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿè®¸å¾ˆå¿«å°±ä¼šæƒ³åˆ°è¿™ç§åšæ³•ï¼š

```python
class Base[A, B, C](BaseModel, ABC):
	# âŒ é”™è¯¯çš„å®ç°ï¼Œè·å–ä¸åˆ° type
    a_type: ClassVar[type] = TypeWrapper[A].type()

class Derived[A, C](Base[A, int, C]): ...

@final
class Final(Derived[str, float]): ...

assert Final.a_type is str
```


# ç›¸å…³æ–‡ç« 

